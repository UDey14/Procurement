# -*- coding: utf-8 -*-
"""Sustainable Supplier Selection Tool.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vNU0l6AURu_gg9Zcm2UWOIujiJcHiDcX

Step 1: Set Up Google Colab and Install Required Packages
"""

# Run this cell in Google Colab
!pip install pandas numpy matplotlib seaborn plotly
print("All required packages installed successfully!")

"""Step 2: Generate Sample Supplier Data"""

# Run this cell to generate sample supplier data
import pandas as pd
import numpy as np

def generate_sample_data(num_suppliers=50):
    """
    Generate sample supplier data with sustainability metrics
    """
    np.random.seed(42)

    data = {
        'supplier_id': range(1, num_suppliers+1),
        'name': [f'Supplier {i}' for i in range(1, num_suppliers+1)],
        'carbon_footprint': np.random.uniform(100, 1000, num_suppliers),
        'recycling_rate': np.random.uniform(20, 95, num_suppliers),
        'energy_efficiency': np.random.uniform(50, 95, num_suppliers),
        'water_usage': np.random.uniform(100, 10000, num_suppliers),
        'waste_production': np.random.uniform(10, 500, num_suppliers),
    }

    # Add certifications (binary flags)
    certifications = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    for cert in certifications:
        data[cert] = np.random.choice([0, 1], size=num_suppliers, p=[0.6, 0.4])

    # Add location and industry
    locations = ['North America', 'Europe', 'Asia', 'South America', 'Africa']
    industries = ['Electronics', 'Textiles', 'Food', 'Chemicals', 'Manufacturing']

    data['location'] = np.random.choice(locations, num_suppliers)
    data['industry'] = np.random.choice(industries, num_suppliers)

    return pd.DataFrame(data)

# Generate and save sample data
df = generate_sample_data()
df.to_csv('supplier_data.csv', index=False)

print(" Sample data generated and saved as 'supplier_data.csv'")
print(f" Data shape: {df.shape}")
print("\n First few rows:")
display(df.head())

print("\n Basic statistics:")
display(df.describe())

# Let's also check certification counts
cert_cols = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
print("\n Certification counts:")
for cert in cert_cols:
    count = df[cert].sum()
    percentage = (count / len(df)) * 100
    print(f"  {cert}: {count} suppliers ({percentage:.1f}%)")

"""Step 3: Create the Scoring Algorithm"""

# Run this cell to create the scoring algorithm
import pandas as pd

def calculate_sustainability_score(row, weights):
    """
    Calculate overall sustainability score based on weighted factors
    """
    # Normalize quantitative metrics (higher is better for most)
    normalized_carbon = 1 - (row['carbon_footprint'] / 1000)  # Lower carbon is better
    normalized_recycling = row['recycling_rate'] / 100
    normalized_energy = row['energy_efficiency'] / 100
    normalized_water = 1 - (row['water_usage'] / 10000)  # Lower water usage is better
    normalized_waste = 1 - (row['waste_production'] / 500)  # Lower waste is better

    # Certification points (qualitative factors)
    cert_cols = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    cert_score = sum(row[cert] for cert in cert_cols) / len(cert_cols)

    # Calculate weighted score
    score = (
        weights['carbon'] * normalized_carbon +
        weights['recycling'] * normalized_recycling +
        weights['energy'] * normalized_energy +
        weights['water'] * normalized_water +
        weights['waste'] * normalized_waste +
        weights['certifications'] * cert_score
    )

    return round(score * 100, 2)  # Convert to percentage

def calculate_scores(df, weights):
    """
    Calculate sustainability scores for all suppliers
    """
    df['sustainability_score'] = df.apply(
        lambda row: calculate_sustainability_score(row, weights),
        axis=1
    )
    return df.sort_values('sustainability_score', ascending=False)

# Default weights
default_weights = {
    'carbon': 0.25,
    'recycling': 0.15,
    'energy': 0.15,
    'water': 0.15,
    'waste': 0.15,
    'certifications': 0.15
}

# Test the scoring function
df = pd.read_csv('supplier_data.csv')

# Test with default weights
scored_df = calculate_scores(df.copy(), default_weights)

print("Top 5 suppliers by sustainability score:")
display(scored_df[['name', 'industry', 'location', 'sustainability_score']].head())

print("\nScore distribution:")
print(f"Average score: {scored_df['sustainability_score'].mean():.2f}")
print(f"Minimum score: {scored_df['sustainability_score'].min():.2f}")
print(f"Maximum score: {scored_df['sustainability_score'].max():.2f}")

# Test with custom weights (emphasizing carbon footprint)
custom_weights = {
    'carbon': 0.35,
    'recycling': 0.10,
    'energy': 0.10,
    'water': 0.10,
    'waste': 0.10,
    'certifications': 0.25
}

custom_scored_df = calculate_scores(df.copy(), custom_weights)
print("\nTop 5 suppliers with custom weights (emphasizing carbon and certifications):")
display(custom_scored_df[['name', 'industry', 'location', 'sustainability_score']].head())

# Save the scoring function to a file for later use
scoring_code = '''
import pandas as pd

def calculate_sustainability_score(row, weights):
    """
    Calculate overall sustainability score based on weighted factors
    """
    # Normalize quantitative metrics (higher is better for most)
    normalized_carbon = 1 - (row['carbon_footprint'] / 1000)
    normalized_recycling = row['recycling_rate'] / 100
    normalized_energy = row['energy_efficiency'] / 100
    normalized_water = 1 - (row['water_usage'] / 10000)
    normalized_waste = 1 - (row['waste_production'] / 500)

    # Certification points (qualitative factors)
    cert_cols = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    cert_score = sum(row[cert] for cert in cert_cols) / len(cert_cols)

    # Calculate weighted score
    score = (
        weights['carbon'] * normalized_carbon +
        weights['recycling'] * normalized_recycling +
        weights['energy'] * normalized_energy +
        weights['water'] * normalized_water +
        weights['waste'] * normalized_waste +
        weights['certifications'] * cert_score
    )

    return round(score * 100, 2)

def calculate_scores(df, weights):
    """
    Calculate sustainability scores for all suppliers
    """
    df['sustainability_score'] = df.apply(
        lambda row: calculate_sustainability_score(row, weights),
        axis=1
    )
    return df.sort_values('sustainability_score', ascending=False)
'''

with open('scoring.py', 'w') as f:
    f.write(scoring_code)

print("Scoring functions saved to 'scoring.py'")

"""Step 4: Create Data Analysis and Visualization Functions"""

# Run this cell to fix the scoring module and create data analysis functions
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# First, let's fix the scoring.py file by adding default_weights
scoring_code = '''
import pandas as pd

# Default weights
default_weights = {
    'carbon': 0.25,
    'recycling': 0.15,
    'energy': 0.15,
    'water': 0.15,
    'waste': 0.15,
    'certifications': 0.15
}

def calculate_sustainability_score(row, weights):
    """
    Calculate overall sustainability score based on weighted factors
    """
    # Normalize quantitative metrics (higher is better for most)
    normalized_carbon = 1 - (row['carbon_footprint'] / 1000)
    normalized_recycling = row['recycling_rate'] / 100
    normalized_energy = row['energy_efficiency'] / 100
    normalized_water = 1 - (row['water_usage'] / 10000)
    normalized_waste = 1 - (row['waste_production'] / 500)

    # Certification points (qualitative factors)
    cert_cols = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    cert_score = sum(row[cert] for cert in cert_cols) / len(cert_cols)

    # Calculate weighted score
    score = (
        weights['carbon'] * normalized_carbon +
        weights['recycling'] * normalized_recycling +
        weights['energy'] * normalized_energy +
        weights['water'] * normalized_water +
        weights['waste'] * normalized_waste +
        weights['certifications'] * cert_score
    )

    return round(score * 100, 2)

def calculate_scores(df, weights):
    """
    Calculate sustainability scores for all suppliers
    """
    df['sustainability_score'] = df.apply(
        lambda row: calculate_sustainability_score(row, weights),
        axis=1
    )
    return df.sort_values('sustainability_score', ascending=False)
'''

with open('scoring.py', 'w') as f:
    f.write(scoring_code)

print("Fixed scoring.py file with default_weights")

# Now let's create the analysis functions without importing from scoring
def calculate_sustainability_score(row, weights):
    """
    Calculate overall sustainability score based on weighted factors
    """
    # Normalize quantitative metrics (higher is better for most)
    normalized_carbon = 1 - (row['carbon_footprint'] / 1000)
    normalized_recycling = row['recycling_rate'] / 100
    normalized_energy = row['energy_efficiency'] / 100
    normalized_water = 1 - (row['water_usage'] / 10000)
    normalized_waste = 1 - (row['waste_production'] / 500)

    # Certification points (qualitative factors)
    cert_cols = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    cert_score = sum(row[cert] for cert in cert_cols) / len(cert_cols)

    # Calculate weighted score
    score = (
        weights['carbon'] * normalized_carbon +
        weights['recycling'] * normalized_recycling +
        weights['energy'] * normalized_energy +
        weights['water'] * normalized_water +
        weights['waste'] * normalized_waste +
        weights['certifications'] * cert_score
    )

    return round(score * 100, 2)

def calculate_scores(df, weights):
    """
    Calculate sustainability scores for all suppliers
    """
    df['sustainability_score'] = df.apply(
        lambda row: calculate_sustainability_score(row, weights),
        axis=1
    )
    return df.sort_values('sustainability_score', ascending=False)

# Default weights
default_weights = {
    'carbon': 0.25,
    'recycling': 0.15,
    'energy': 0.15,
    'water': 0.15,
    'waste': 0.15,
    'certifications': 0.15
}

def analyze_supplier_data():
    """
    Analyze the supplier data and generate insights
    """
    # Load data
    df = pd.read_csv('supplier_data.csv')

    # Calculate scores
    scored_df = calculate_scores(df, default_weights)

    # Basic statistics
    print("=== BASIC STATISTICS ===")
    print(f"Total suppliers: {len(df)}")
    print(f"Industries: {', '.join(df['industry'].unique())}")
    print(f"Locations: {', '.join(df['location'].unique())}")

    # Certification statistics
    cert_cols = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    print("\n=== CERTIFICATION STATISTICS ===")
    for cert in cert_cols:
        count = df[cert].sum()
        percentage = (count / len(df)) * 100
        print(f"{cert}: {count} suppliers ({percentage:.1f}%)")

    # Score distribution
    print("\n=== SCORE DISTRIBUTION ===")
    print(f"Average score: {scored_df['sustainability_score'].mean():.2f}")
    print(f"Minimum score: {scored_df['sustainability_score'].min():.2f}")
    print(f"Maximum score: {scored_df['sustainability_score'].max():.2f}")

    # Industry analysis
    print("\n=== INDUSTRY ANALYSIS ===")
    industry_stats = scored_df.groupby('industry')['sustainability_score'].agg(['mean', 'count'])
    print(industry_stats)

    # Location analysis
    print("\n=== LOCATION ANALYSIS ===")
    location_stats = scored_df.groupby('location')['sustainability_score'].agg(['mean', 'count'])
    print(location_stats)

    return scored_df

def create_visualizations(df):
    """
    Create visualizations of the supplier data
    """
    # Set up the plotting style
    sns.set_style("whitegrid")
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))

    # 1. Score distribution
    axes[0, 0].hist(df['sustainability_score'], bins=15, edgecolor='black', alpha=0.7, color='skyblue')
    axes[0, 0].set_title('Sustainability Score Distribution')
    axes[0, 0].set_xlabel('Score')
    axes[0, 0].set_ylabel('Number of Suppliers')

    # 2. Average score by industry
    industry_scores = df.groupby('industry')['sustainability_score'].mean().sort_values()
    industry_scores.plot(kind='bar', ax=axes[0, 1], color='lightgreen')
    axes[0, 1].set_title('Average Sustainability Score by Industry')
    axes[0, 1].set_xlabel('Industry')
    axes[0, 1].set_ylabel('Average Score')
    axes[0, 1].tick_params(axis='x', rotation=45)

    # 3. Average score by location
    location_scores = df.groupby('location')['sustainability_score'].mean().sort_values()
    location_scores.plot(kind='bar', ax=axes[1, 0], color='lightcoral')
    axes[1, 0].set_title('Average Sustainability Score by Location')
    axes[1, 0].set_xlabel('Location')
    axes[1, 0].set_ylabel('Average Score')
    axes[1, 0].tick_params(axis='x', rotation=45)

    # 4. Correlation heatmap
    numeric_cols = ['carbon_footprint', 'recycling_rate', 'energy_efficiency',
                   'water_usage', 'waste_production', 'sustainability_score']
    correlation_matrix = df[numeric_cols].corr()
    sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0, ax=axes[1, 1])
    axes[1, 1].set_title('Correlation Heatmap')

    plt.tight_layout()
    plt.savefig('supplier_analysis.png', dpi=300, bbox_inches='tight')
    plt.show()

    print("Visualizations saved as 'supplier_analysis.png'")

# Run the analysis
print("Analyzing supplier data...")
scored_df = analyze_supplier_data()

print("\nCreating visualizations...")
create_visualizations(scored_df)

# Show top 10 suppliers
print("\n=== TOP 10 SUPPLIERS ===")
top_10 = scored_df[['name', 'industry', 'location', 'sustainability_score']].head(10)
display(top_10)

# Save the analysis functions to a file for later use
analysis_code = '''
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def calculate_sustainability_score(row, weights):
    """
    Calculate overall sustainability score based on weighted factors
    """
    # Normalize quantitative metrics (higher is better for most)
    normalized_carbon = 1 - (row['carbon_footprint'] / 1000)
    normalized_recycling = row['recycling_rate'] / 100
    normalized_energy = row['energy_efficiency'] / 100
    normalized_water = 1 - (row['water_usage'] / 10000)
    normalized_waste = 1 - (row['waste_production'] / 500)

    # Certification points (qualitative factors)
    cert_cols = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    cert_score = sum(row[cert] for cert in cert_cols) / len(cert_cols)

    # Calculate weighted score
    score = (
        weights['carbon'] * normalized_carbon +
        weights['recycling'] * normalized_recycling +
        weights['energy'] * normalized_energy +
        weights['water'] * normalized_water +
        weights['waste'] * normalized_waste +
        weights['certifications'] * cert_score
    )

    return round(score * 100, 2)

def calculate_scores(df, weights):
    """
    Calculate sustainability scores for all suppliers
    """
    df['sustainability_score'] = df.apply(
        lambda row: calculate_sustainability_score(row, weights),
        axis=1
    )
    return df.sort_values('sustainability_score', ascending=False)

# Default weights
default_weights = {
    'carbon': 0.25,
    'recycling': 0.15,
    'energy': 0.15,
    'water': 0.15,
    'waste': 0.15,
    'certifications': 0.15
}

def analyze_supplier_data():
    """
    Analyze the supplier data and generate insights
    """
    # Load data
    df = pd.read_csv('supplier_data.csv')

    # Calculate scores
    scored_df = calculate_scores(df, default_weights)

    # Basic statistics
    print("=== BASIC STATISTICS ===")
    print(f"Total suppliers: {len(df)}")
    print(f"Industries: {', '.join(df['industry'].unique())}")
    print(f"Locations: {', '.join(df['location'].unique())}")

    # Certification statistics
    cert_cols = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    print("\n=== CERTIFICATION STATISTICS ===")
    for cert in cert_cols:
        count = df[cert].sum()
        percentage = (count / len(df)) * 100
        print(f"{cert}: {count} suppliers ({percentage:.1f}%)")

    # Score distribution
    print("\n=== SCORE DISTRIBUTION ===")
    print(f"Average score: {scored_df['sustainability_score'].mean():.2f}")
    print(f"Minimum score: {scored_df['sustainability_score'].min():.2f}")
    print(f"Maximum score: {scored_df['sustainability_score'].max():.2f}")

    # Industry analysis
    print("\n=== INDUSTRY ANALYSIS ===")
    industry_stats = scored_df.groupby('industry')['sustainability_score'].agg(['mean', 'count'])
    print(industry_stats)

    # Location analysis
    print("\n=== LOCATION ANALYSIS ===")
    location_stats = scored_df.groupby('location')['sustainability_score'].agg(['mean', 'count'])
    print(location_stats)

    return scored_df

def create_visualizations(df):
    """
    Create visualizations of the supplier data
    """
    # Set up the plotting style
    sns.set_style("whitegrid")
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))

    # 1. Score distribution
    axes[0, 0].hist(df['sustainability_score'], bins=15, edgecolor='black', alpha=0.7, color='skyblue')
    axes[0, 0].set_title('Sustainability Score Distribution')
    axes[0, 0].set_xlabel('Score')
    axes[0, 0].set_ylabel('Number of Suppliers')

    # 2. Average score by industry
    industry_scores = df.groupby('industry')['sustainability_score'].mean().sort_values()
    industry_scores.plot(kind='bar', ax=axes[0, 1], color='lightgreen')
    axes[0, 1].set_title('Average Sustainability Score by Industry')
    axes[0, 1].set_xlabel('Industry')
    axes[0, 1].set_ylabel('Average Score')
    axes[0, 1].tick_params(axis='x', rotation=45)

    # 3. Average score by location
    location_scores = df.groupby('location')['sustainability_score'].mean().sort_values()
    location_scores.plot(kind='bar', ax=axes[1, 0], color='lightcoral')
    axes[1, 0].set_title('Average Sustainability Score by Location')
    axes[1, 0].set_xlabel('Location')
    axes[1, 0].set_ylabel('Average Score')
    axes[1, 0].tick_params(axis='x', rotation=45)

    # 4. Correlation heatmap
    numeric_cols = ['carbon_footprint', 'recycling_rate', 'energy_efficiency',
                   'water_usage', 'waste_production', 'sustainability_score']
    correlation_matrix = df[numeric_cols].corr()
    sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0, ax=axes[1, 1])
    axes[1, 1].set_title('Correlation Heatmap')

    plt.tight_layout()
    plt.savefig('supplier_analysis.png', dpi=300, bbox_inches='tight')
    plt.show()

    print("Visualizations saved as 'supplier_analysis.png'")
'''

with open('analysis.py', 'w') as f:
    f.write(analysis_code)

print("Analysis functions saved to 'analysis.py'")

"""Step 6: Deployment Options and Setup"""

# Run this cell to create the fixed app.py for deployment
fixed_app_code = '''
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import os

# Set page config
st.set_page_config(
    page_title="Sustainable Supplier Selection",
    page_icon="🌱",
    layout="wide"
)

# Load data with error handling
@st.cache_data
def load_data():
    try:
        # Try to load the data file
        return pd.read_csv('supplier_data.csv')
    except FileNotFoundError:
        # If file not found, create sample data
        st.warning("supplier_data.csv not found. Generating sample data...")
        return generate_sample_data()

def generate_sample_data(num_suppliers=50):
    """
    Generate sample supplier data with sustainability metrics
    """
    import numpy as np

    np.random.seed(42)

    data = {
        'supplier_id': range(1, num_suppliers+1),
        'name': [f'Supplier {i}' for i in range(1, num_suppliers+1)],
        'carbon_footprint': np.random.uniform(100, 1000, num_suppliers),
        'recycling_rate': np.random.uniform(20, 95, num_suppliers),
        'energy_efficiency': np.random.uniform(50, 95, num_suppliers),
        'water_usage': np.random.uniform(100, 10000, num_suppliers),
        'waste_production': np.random.uniform(10, 500, num_suppliers),
    }

    # Add certifications (binary flags)
    certifications = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    for cert in certifications:
        data[cert] = np.random.choice([0, 1], size=num_suppliers, p=[0.6, 0.4])

    # Add location and industry
    locations = ['North America', 'Europe', 'Asia', 'South America', 'Africa']
    industries = ['Electronics', 'Textiles', 'Food', 'Chemicals', 'Manufacturing']

    data['location'] = np.random.choice(locations, num_suppliers)
    data['industry'] = np.random.choice(industries, num_suppliers)

    df = pd.DataFrame(data)

    # Save the generated data for future use
    try:
        df.to_csv('supplier_data.csv', index=False)
    except:
        pass  # If we can't save, just continue

    return df

# Scoring functions
def calculate_sustainability_score(row, weights):
    """
    Calculate overall sustainability score based on weighted factors
    """
    # Normalize quantitative metrics (higher is better for most)
    normalized_carbon = 1 - (row['carbon_footprint'] / 1000)
    normalized_recycling = row['recycling_rate'] / 100
    normalized_energy = row['energy_efficiency'] / 100
    normalized_water = 1 - (row['water_usage'] / 10000)
    normalized_waste = 1 - (row['waste_production'] / 500)

    # Certification points (qualitative factors)
    cert_cols = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    cert_score = sum(row[cert] for cert in cert_cols) / len(cert_cols)

    # Calculate weighted score
    score = (
        weights['carbon'] * normalized_carbon +
        weights['recycling'] * normalized_recycling +
        weights['energy'] * normalized_energy +
        weights['water'] * normalized_water +
        weights['waste'] * normalized_waste +
        weights['certifications'] * cert_score
    )

    return round(score * 100, 2)

def calculate_scores(df, weights):
    """
    Calculate sustainability scores for all suppliers
    """
    df['sustainability_score'] = df.apply(
        lambda row: calculate_sustainability_score(row, weights),
        axis=1
    )
    return df.sort_values('sustainability_score', ascending=False)

# Default weights
default_weights = {
    'carbon': 0.25,
    'recycling': 0.15,
    'energy': 0.15,
    'water': 0.15,
    'waste': 0.15,
    'certifications': 0.15
}

def main():
    st.title("Sustainable Supplier Selection Tool")
    st.markdown("Identify and evaluate suppliers based on sustainability metrics")

    # Load data
    df = load_data()

    # Sidebar filters
    st.sidebar.header("Filters")

    # Certification filters
    st.sidebar.subheader("Certifications")
    cert_cols = ['ISO_14001', 'Fair_Trade', 'Organic', 'B_Corp', 'Rainforest_Alliance']
    cert_filters = {}
    for cert in cert_cols:
        cert_filters[cert] = st.sidebar.checkbox(cert.replace('_', ' '), value=True)

    # Industry filter
    industries = st.sidebar.multiselect(
        "Industry",
        options=df['industry'].unique(),
        default=df['industry'].unique()
    )

    # Location filter
    locations = st.sidebar.multiselect(
        "Location",
        options=df['location'].unique(),
        default=df['location'].unique()
    )

    # Score weights adjustment
    st.sidebar.subheader("Scoring Weights")
    weights = {}
    weights['carbon'] = st.sidebar.slider("Carbon Footprint", 0.0, 0.3, 0.25, 0.05)
    weights['recycling'] = st.sidebar.slider("Recycling Rate", 0.0, 0.3, 0.15, 0.05)
    weights['energy'] = st.sidebar.slider("Energy Efficiency", 0.0, 0.3, 0.15, 0.05)
    weights['water'] = st.sidebar.slider("Water Usage", 0.0, 0.3, 0.15, 0.05)
    weights['waste'] = st.sidebar.slider("Waste Production", 0.0, 0.3, 0.15, 0.05)
    weights['certifications'] = st.sidebar.slider("Certifications", 0.0, 0.3, 0.15, 0.05)

    # Check if weights sum to 1
    total_weight = sum(weights.values())
    if total_weight != 1.0:
        st.sidebar.warning(f"Weights sum to {total_weight:.2f} (should sum to 1.0)")

    # Apply filters
    filtered_df = df.copy()

    # Apply certification filters
    for cert, include in cert_filters.items():
        if not include:
            filtered_df = filtered_df[filtered_df[cert] == 0]

    # Apply industry and location filters
    filtered_df = filtered_df[filtered_df['industry'].isin(industries)]
    filtered_df = filtered_df[filtered_df['location'].isin(locations)]

    # Calculate scores
    scored_df = calculate_scores(filtered_df, weights)

    # Display top suppliers
    st.header("Top Sustainable Suppliers")

    col1, col2, col3 = st.columns([2, 1, 1])

    with col1:
        st.dataframe(
            scored_df[['name', 'industry', 'location', 'sustainability_score']].head(10),
            use_container_width=True
        )

    with col2:
        # Sustainability score distribution
        fig1 = px.histogram(scored_df, x='sustainability_score',
                           title="Score Distribution")
        st.plotly_chart(fig1, use_container_width=True)

    with col3:
        # Average scores by industry
        industry_scores = scored_df.groupby('industry')['sustainability_score'].mean().reset_index()
        fig2 = px.bar(industry_scores, x='industry', y='sustainability_score',
                     title="Average Score by Industry")
        st.plotly_chart(fig2, use_container_width=True)

    # Detailed supplier view
    st.header("Supplier Details")
    selected_supplier = st.selectbox(
        "Select a supplier to view details",
        options=scored_df['name'].tolist()
    )

    if selected_supplier:
        supplier_data = scored_df[scored_df['name'] == selected_supplier].iloc[0]

        col1, col2 = st.columns(2)

        with col1:
            st.subheader("Sustainability Metrics")
            metrics = {
                'Carbon Footprint': supplier_data['carbon_footprint'],
                'Recycling Rate': supplier_data['recycling_rate'],
                'Energy Efficiency': supplier_data['energy_efficiency'],
                'Water Usage': supplier_data['water_usage'],
                'Waste Production': supplier_data['waste_production']
            }

            for metric, value in metrics.items():
                st.metric(metric, f"{value:.2f}")

        with col2:
            st.subheader("Certifications")
            certs = []
            for cert in cert_cols:
                if supplier_data[cert] == 1:
                    certs.append(cert.replace('_', ' '))

            if certs:
                for cert in certs:
                    st.success(f"{cert}")
            else:
                st.warning("No certifications")

    # Scenario simulation
    st.header("Scenario Simulation")
    st.subheader("Compare environmental impact of switching suppliers")

    col1, col2 = st.columns(2)

    with col1:
        current_supplier = st.selectbox(
            "Current Supplier",
            options=scored_df['name'].tolist(),
            key="current"
        )

    with col2:
        alternative_supplier = st.selectbox(
            "Alternative Supplier",
            options=scored_df['name'].tolist(),
            key="alternative"
        )

    if current_supplier and alternative_supplier and current_supplier != alternative_supplier:
        current = scored_df[scored_df['name'] == current_supplier].iloc[0]
        alternative = scored_df[scored_df['name'] == alternative_supplier].iloc[0]

        # Calculate impact differences
        impact_diff = {
            'Carbon Footprint': alternative['carbon_footprint'] - current['carbon_footprint'],
            'Water Usage': alternative['water_usage'] - current['water_usage'],
            'Waste Production': alternative['waste_production'] - current['waste_production']
        }

        # Display comparison
        st.subheader("Environmental Impact Comparison")

        fig = go.Figure()

        fig.add_trace(go.Bar(
            name='Current',
            x=list(impact_diff.keys()),
            y=[current['carbon_footprint'], current['water_usage'], current['waste_production']],
            marker_color='blue'
        ))

        fig.add_trace(go.Bar(
            name='Alternative',
            x=list(impact_diff.keys()),
            y=[alternative['carbon_footprint'], alternative['water_usage'], alternative['waste_production']],
            marker_color='green'
        ))

        fig.update_layout(barmode='group', title_text="Environmental Impact Comparison")
        st.plotly_chart(fig, use_container_width=True)

        # Summary of changes
        improvements = []
        declines = []

        for metric, diff in impact_diff.items():
            if diff < 0:
                improvements.append(f"{metric}: {abs(diff):.2f} reduction")
            else:
                declines.append(f"{metric}: {diff:.2f} increase")

        if improvements:
            st.success("Improvements: " + ", ".join(improvements))
        if declines:
            st.error("Declines: " + ", ".join(declines))

        # Overall recommendation
        if len(improvements) > len(declines):
            st.success("Recommendation: Consider switching to this supplier")
        elif len(improvements) < len(declines):
            st.error("Recommendation: Not recommended to switch to this supplier")
        else:
            st.warning("Recommendation: Mixed impact - consider other factors")
    elif current_supplier == alternative_supplier:
        st.warning("Please select different suppliers for comparison")

if __name__ == "__main__":
    main()
'''

with open('app.py', 'w') as f:
    f.write(fixed_app_code)

print("✅ Fixed app.py created with error handling")
print("The app will now generate sample data if supplier_data.csv is not found")

# Create a new zip file with the fixed app
!zip -r sustainable_supplier_tool_fixed.zip app.py supplier_data.csv requirements.txt README.md scoring.py

print("\n✅ New zip file created: sustainable_supplier_tool_fixed.zip")
print("\n📥 DOWNLOAD INSTRUCTIONS:")
print("1. Download the new zip file from the left sidebar")
print("2. Replace the files in your GitHub repository with these new files")
print("3. Go back to Streamlit Cloud and redeploy your app")

